### Java 代码如何运行 
- 编译：将 .java 代码编译成 .class 后缀的字节码文件
- 加载：类加载器将编译好的 .class 字节码文件中的类加载到 JVM 中
- 运行：JVM 基于自己的字节码执行引擎开始执行这些类
### 类加载过程 
- 加载--》验证--》准备--》解析--》初始化--》使用--》卸载
- 验证阶段：根据 Java 虚拟机规范，校验加载进来的 .class 文件中的内容，是否符合指定的规范
- 准备阶段：给加载进来的类分配好内存空间，类变量也分配好内存空间，并给了默认的初始值
- 解析阶段：符号引用替换为直接引用
- 初始化阶段：赋值
  - 规则：如果初始化一个类时，父类还没初始化，那么必须先初始化父类
### 类加载器
- 基于 Java 虚拟机的角度：启动类加载器（Bootstrap ClassLoader）、其他所有的类加载器（独立存在于虚拟机外部），全部继承自抽象类 java.lang.ClassLoader
- 基于 Java 开发人员的角度：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）、应用程序类加载器（Application Class Loader）
### 双亲委派模型
- 含义
	- 当某个类加载器需要加载某个 .class 文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类
- 好处
	-  Java 中的类随着它的类加载器一起具备了一种带有优先级的层级关系
	-  例如：Java.lang.Object 类，可以保证 Object 类在程序的各种类加载环境中都是同一个类
#### Tomcat 类加载器
https://www.processon.com/diagraming/5e83ed97e4b08c5b86f5e4d2
### Java 运行时数据区域
- 堆：存放在代码中创建的各种对象（存放对象实例、各个线程共享的内存区域）

- 方法区：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据（各个线程共享的内存区域）

- Java 虚拟机栈：存放方法内的局部变量等（线程私有）

- 本地方法栈：为虚拟机使用到的本地（Native）方法服务（线程私有）

- 程序计数器：记录当前执行的字节码指令的位置（线程私有）

- 创建的对象在 Java 堆内存中占用多少空间

  - 一个对象对空间的占用
    - 对象本身的一些信息
    - 对象的实例变量作为数据占用的空间
  - 对象头在 64 位的 Linux 操作系统上，会占用 16 字节，假如实例对象内部有 int 类型的实例变量占用 4 个字节，long 类型占用 8 个字节

### JVM 分代模型
- 新生代：短期存活的对象
- 老年代：长期存活的对象
- 永久代（Java 8 为元空间）：方法区、存放一些类信息
- 大部分的正常对象，都是优先在新生代分配内存的
- 如果一个实例对象在新生代中，成功的在 15 次垃圾回收之后，还是没被回收掉就会进入老年代
- 每个线程都有 Java 虚拟机栈，里面也有方法的局部变量等数据，这个 Java 虚拟机栈需要进行垃圾回收吗
  - JVM 里垃圾回收针对的是新生代、老年代还有方法区 (永久代)，不会针对方法的栈帧。方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存清理了
#### 方法区会进行垃圾回收
- 首先该类的所有实例对象都已经从 Java堆内存里被回收
- 其次加载该类的 ClassLoader 已经被回收
- 最后该类的 Class 对象没有任何引用
### 对象在 JVM 内存中如何分配
- 大部分正常对象都是优先在新生代分配内存
- 新生代内存空间的垃圾回收称为 "Minor GC" 或 "Young GC"
### JVM 内存核心参数
- -Xms：Java 堆内存大小
- -Xmx：Java 堆内存得最大大小
- -Xmn：Java 堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
- -XX:PermSize：永久代大小（JDK 1.8 以后的版本：-XX:MetaspaceSize）
- -XX:MaxPermSize：永久代最大大小（JDK 1.8 以后的版本：-XX:MaxMetaspaceSize）
- -Xss：每个线程的栈内存大小
### 支付系统，设置 JVM 参数
- 假设每天 100 万个支付订单

- 假设每天高峰期大概是几个小时，用 100 万平均分配到几个小时里，大概每秒是 100 个订单左右

- 假设支付系统部署在 3 台机器，每台机器实际上每秒处理 30 笔订单

- 每台机器一秒收到 30 个支付订单的请求有，然后在 JVM的新生代里创建了 30 个支付订单的对象

- 一般来说，支付订单核心类按照 20 个实例变量来计算，就算一个支付订单占 500 字节的内存空间，不到 1 kb

- 30 个支付订单对象，大概占据的空间是 30 * 500 字节 = 15000 字节，大概 15 kb

- 真实的支付系统线上运行，肯定每秒创建大量其他的对象，估算可以将之前的计算结果扩大 10 倍~20 倍

- 那么每秒钟创建出来的被栈内存的局部变量引用的对象大致占据的内存空间就在几百 KB~1MB之间

- 机器采用 4 核 8G，然后 -Xms 和 -Xmx 设置为 3G，给整个堆内存 3G 内存空间，-Xmn 设置为 2G，给新生代 2G 内存空间

- 如果合理设置永久代大小
  
  - 一般设置几百 MB，因为主要存放一些类的信息
  
- 如何合理设置栈内存大小
  
  - 一般默认是 512 KB～1MB，用来存放线程执行方法期间的各种局部变量
  
### 支付系统高峰期
- 需要处理的请求估算：100 万 / 24 * 3600 = 12，根据 28 法则，大部分请求发生在中午 12 点 到 13 点以及晚上的 18 点到 19 点，所以 80 万请求 / (2 * 3600) = 111，即算出如果单台每秒大概是 100 多个请求
- 还有就是在完整的支付系统内存占用进行评估时，可以将之前的计算结果扩大 10 到 20 倍，也就是说每秒内存除了创建支付订单对象还会创建数十种对象，这样计算的结果是 30 * 500 字节 * 20 倍 = 300000 字节 = 300 KB

### 被哪些变量引用的对象是不能回收的

- 可达性分析算法

  - 先通过 GC Roots 方法，看看各个对象是否被 GC Roots 引用，如果是，那就是存活对象，否则就是垃圾对象

  

- 只要你的对象被方法的局部变量、类的静态变量给引用了，就不会被回收

- 有 GC Roots 引用的对象不能回收，没有 GC Roots 引用的对象可以回收，如果有 GC Roots 引用，但是如果是软引用或者弱引用，也有可能被回收

- Java 的不同引用类型
  - 强引用
  - 软引用
  - 弱引用
  - 虚引用

### 标记-复制算法

- 1 个 Eden 区和 2 个 Survivor 区：其中 Eden 区占 80% 内存空间，每一个 Survivor 区各占 10% 内存空间
- 新生代的垃圾回收算法

### 年轻代和老年代分别适合怎样的算法

- 躲过 15 次 GC 之后进入老年代
- 具体多少岁进入老年代，可以通过设置 JVM 参数 "-XX:MaxTenuringThreshold" 来设置，默认是 15 岁
- 年龄 1 + 年龄 2 + .... + 年龄 n 的多个年龄对象综合超过了 Survivor 区域的 50%，此时就会把年龄 n 以上的对象都放入老年代
- -XX:PretenureSizeThreshold，可以把它的值设置为字节数，比如 "1048576" 字节，就是 1 MB，大于这个大小的对象直接放入老年代
- -XX:HandlePromotionFailure
- 如果 Full GC 之后，老年代还是没有足够的空间存放 Minor GC 之后的剩余存活对象，那么就会导致 OOM
- 老年代触发垃圾回收的时机
  - 在 Minor GC 之前，检查发现 Minor GC 之后进入老年代的对象太多了，老年代放不下，此时需要提前触发 Full GC 然后再带着进行 Minor GC
  - 在 Minor GC 之后，发现剩余对象太多放入老年代放不下

### 老年代算法

- 标记-整理算法
- 所谓的 JVM 优化，就是尽可能让对象都在新生代分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收

### 垃圾回收器

- ParNew 垃圾回收器：多线程收集器，针对新生代采用的就是标记-复制算法
- Serial 收集器：单线程工作的收集器
- CMS 垃圾回收器：专门负责老年代的垃圾回收，基于标记-清除算法实现的
  - 垃圾回收线程和系统工作线程尽量同时执行的模式来处理
  - CMS 在执行一次垃圾回收的过程分为 4 个阶段
    - 初始标记
      - 虽然说要造成 Stop the World 暂停一切工作线程，但是其实影响不大，因为它速度够快，仅仅标记 GC Roots 直接引用的哪些对象
    - 并发标记
      - 让系统可以随意创建各种新对象，继续运行
      - 在运行期间可能会创建新的存活对象，也可能让部分存活对象失去引用，变成垃圾对象。在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行 GC Roots 追踪
      - 对老年代所有对象进行 GC Roots 追踪，其实是最耗时的
    - 重新标记
      - 对并发标记阶段中被系统程序运行变动的少数对象进行标记，所以运行速度很快
    - 并发清理
      - 让系统程序随意运行，然后清理掉之前标记为垃圾的对象即可
  - -XX:CMSInitiatingOccupancyFaction：用来设置老年代占用多少比例的时候触发 CMS 垃圾回收，JDK 1.6 里面默认的值是 92%
    - 老年代占用了 92% 空间，就自动进行 CMS 垃圾回收，预留 8% 的空间给并发回收期间，系统程序把一些新对象放入老年代中
  - 如果 CMS 垃圾回收期间，系统程序要放入老年代的对象大于可用内存空间，此时会如何
    - 会发生 Concurrent Model Failure，即并发垃圾回收失败了，我一边回收，你一边把对象放入老年代他，内存不够，此时就会自动用 "Serial Old" 垃圾回收器代替 CMS，就是直接强行把系统程序 "Stop The World"，重新进行长时间的 GC Roots 追踪，标记出来全部垃圾对象，不允许新的对象产生，然后一次性把垃圾对象都回收掉，回收完之后再恢复系统线程
    - 在生产实践中，自动触发 CMS 垃圾回收的比例需要合理优化，避免 "Concurrent Model Failure"
  - -XX:+UseCMSCompactAtFullCollection：默认打开
    - 在 Full GC 之后要再次进行 "Stop the World"，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出大片连续内存空间，避免内存碎片
  - -XX:CMSFullGCsBeforeCompaction
    - 执行多少次 Full GC 之后再执行一次内存碎片整理的工作，默认是 0，即每次 Full GC 之后都会进行一次内存整理
  - CMS 垃圾回收器的优缺点
    - 优点：并发收集、低延迟
    - 缺点：回收时间长，消耗 CPU 资源，吞吐量不如Parallel、无法处理浮动垃圾、会产生大量的空间碎片、并发模式失败：Concurrent model failure
- 触发老年代 GC 的时机
  - 老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发 Full GC，所以一般空间担保参数都会打开
  - 老年代可用内存小于历次新生代 GC 后进入老年代的平均对象大小，此时会提前 Full GC
  - 新生代 Minor GC 后的存活对象大于 Survivor，那么就会进入老年代，而此时老年代内存不足
  - -XX:CMSInitiatingOccupancyFaction 参数设置
  - 看 25
- 启动系统时指定使用 ParNew 垃圾回收器
  - -XX:+UseParNewGC







