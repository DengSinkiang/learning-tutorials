# 如何用三行代码找到 "最终推荐人"

### 什么是递归

- 递归是一种应用非常广泛的算法(或者编程技巧)。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等

- 方法或函数调用自身的方式称为递归调用，调用称为 "递"，返回称为 "归"

- 基本上，所有的递归问题都可以用递推公式来表示，比如:

  ```java
  f(n) = f(n-1) + 1;
  f(n) = f(n-1) + f(n-2);
  f(n)=n * f(n-1);
  ```

### 递归的优缺点

- 优点：代码的表达力很强，写起来简洁
- 缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题

### 什么样的问题可以用递归解决

- 一个问题只要同时满足以下 3 个条件，就可以用递归来解决：
  - 问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题
  - 问题与子问题，除了数据规模不同，求解思路完全一样
  - 存在递归终止条件

### 如何实现递归

- 递归代码编写
  - 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条 件，最后将递推公式和终止条件翻译成代码
- 递归代码理解
  - 对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区
  - 正确的思维方式
    - 如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题 A。而 且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了
- 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑 去分解递归的每个步骤

### 递归常见问题及解决方案

- 警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出
- 警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算

### 如何将递归改写为非递归代码

- 笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现

### 如何用三行代码找到 "最终推荐人"

```
long findRootReferrerId(long actorId) {
	long referrerId = select referrer_id from [table] where actor_id = actorId; 
  if (referrerId == null) return actorId;
	return findRootReferrerId(referrerId);
}
```

- 实际项目中，上面的代码并不能工作，存在两个问题
  - 如果递归很深，可能会有堆栈溢出的问题 
    - 可以用限制递归深度来解决
  - 如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方 便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C的推荐人是 A，这样就会发生死循环 
    - 也可以用限制递归深度来解决
    - 还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种 "环" 的存在