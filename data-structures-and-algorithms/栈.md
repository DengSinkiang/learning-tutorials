# 如何实现浏览器的前进和后退功能

### 如何理解 "栈"

- 后进先出，先进后出，典型的 "栈" 结构

- 从操作特性上来看，栈是一种 "操作受限" 的线性表，只允许在一端插入数据和删除数据
- 当某个数据集合只涉及在⼀端插⼊和删除数据，并且满⾜后进先出、先进后出的特性，我们就应该⾸选 "栈" 这种数据结构

### 如何实现一个 "栈"

- 栈既可以⽤数组来实现，也可以⽤链表来实现。⽤数组实现的栈，我们叫作顺序栈，⽤链表实现的栈，我们叫作链式栈

- 不管是顺序栈还是链式栈，我们存储数据只需要⼀个⼤⼩为n的数组就够了。在⼊栈和出栈过程中，只需要⼀两个临时变量存储空间，所以空间复杂度是 O(1)。注意，这⾥存储数据需要⼀个⼤⼩为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这n个空间是必须的，⽆法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运⾏还需要额外的存储空间

- 不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)

- 代码实现：用数组实现栈

  ```java
  /**
   * @Description: 基于数组实现栈
   * @Author: dengxj
   * @Date: 2020/12/4 9:35
   * @Version: 1.0
   */
  public class StackOnArray {
      /**
       * 数组
       */
      private final String[] items;
      /**
       * 栈中元素个数
       */
      private int count;
      /**
       * 栈的⼤⼩
       */
      private final int n;
  
      /**
       * 初始化数组，申请⼀个⼤⼩为n的数组空间
       * @param n
       */
      public StackOnArray(int n) {
          this.items = new String[n];
          this.n = n;
          this.count = 0;
      }
  
      /**
       * ⼊栈操作
       * @param item
       * @return
       */
      public boolean push(String item) {
          // 数组空间不够了，直接返回 false，⼊栈失败。
          if (count == n) {
              return false;
          }
          // 将 item 放到下标为 count 的位置，并且 count 加⼀
          items[count] = item;
          ++count;
          return true;
      }
  
      /**
       * 出栈操作
       * @return
       */
      public String pop() {
          // 栈为空，则直接返回 null
          if (count == 0) {
              return null;
          }
          // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减⼀
          String tmp = items[count - 1];
          --count;
          return tmp;
      }
  }
  ```

- 代码实现：用链表实现栈

  ```java
  /**
   * @Description: 基于链表实现栈
   * @Author: dengxj
   * @Date: 2020/12/4 9:40
   * @Version: 1.0
   */
  public class StackOnLinkedList {
  
      private Node top = null;
      public void push(int value) {
          Node newNode = new Node(value, null);
          // 判断是否栈空
          if (top != null) {
              newNode.next = top;
          }
          top = newNode;
      }
  
      /**
       * 用 -1 表示栈中没有数据
       * @return
       */
      public int pop() {
          if (top == null) {
              return -1;
          }
          int value = top.data;
          top = top.next;
          return value;
      }
  
      public void printAll() {
          Node p = top;
          while (p != null) {
              System.out.print(p.data + " ");
              p = p.next;
          }
          System.out.println();
      }
  
      private static class Node {
          private final int data;
          private Node next;
  
          public Node(int data, Node next) {
              this.data = data;
              this.next = next;
          }
  
          public int getData() {
              return data;
          }
      }
  }
  ```

### 支持动态扩容的顺序栈（复杂度分析）

- 对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。但是，对于⼊栈操作来说，情况就不⼀样了。当栈中有空闲空间时，⼊栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了O(n)
- 对于⼊栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。⼊栈操作的均摊时间复杂度就为 O(1)

### 栈在函数调用中的应用

- 经典应用场景：函数调用栈
  - 操作系统给每个线程分配了⼀块独⽴的内存空间，这块内存被组织成“栈”这种结构,⽤来存储函数调⽤时的临时变量。每进⼊⼀个函数，就会将临时变量作为⼀个栈帧⼊栈，当被调⽤函数执⾏完成，返回之后，将这个函数对应的栈帧出栈

### 栈在表达式求值中的应用

- 常见应用场景：编译器如何利⽤栈来实现表达式求值。例如：34+13*9+44-12/3
  - 编译器就是通过两个栈来实现的。其中⼀个保存操作数的栈，另⼀个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压⼊操作数栈；当遇到运算符，就与运算符栈的栈顶元素进⾏⽐较。如果⽐运算符栈顶元素的优先级⾼，就将当前运算符压⼊栈；如果⽐运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进⾏计算，再把计算完的结果压⼊操作数栈，继续⽐较

### 栈在括号匹配中的应用

- 借助栈来检查表达式中的括号是否匹配。例如：{[{}]} 或 [{()}([])] 等都为合法格式，⽽ {[}()] 或 [({)] 为不合法的格式
  - ⽤栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压⼊栈中；当扫描到右括号时，从栈顶取出⼀个左括号。如果能够匹配，⽐如 "(" 跟 ")" 匹配，"[" 跟 "]" 匹配，"{" 跟 "}" 匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为⾮法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为⾮法格式

### 思考题

- 如何实现浏览器的前进、后退功能
  - 使⽤两个栈，X 和 Y，我们把⾸次浏览的⻚⾯依次压⼊栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放⼊栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放⼊栈 X 中。当栈 X 中没有数据时，那就说明没有⻚⾯可以继续后退浏览了。当栈Y中没有数据，那就说明没有⻚⾯可以点击前进按钮浏览了
- 函数调⽤栈来保存临时变量，为什么函数调⽤要⽤ "栈" 来保存临时变量呢？⽤其他数据结构不⾏吗
  - 其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择
  - 从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内
- JVM 内存管理中有个 "堆栈" 的概念。栈内存⽤来存储局部变量和⽅法调⽤，堆内存⽤来存储 Java 中的对象。
  那 JVM ⾥⾯的 "栈" 跟我们这⾥说的 "栈" 是不是⼀回事呢？如果不是，那它为什么⼜叫作 "栈" 呢
  - 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构
  - 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区
  - 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换
  - 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收
  - 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收
  - 堆区：new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据